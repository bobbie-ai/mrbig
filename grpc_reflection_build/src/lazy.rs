use crate::symbol_map::SymbolMap;
use prost::Message;
use prost_types::FileDescriptorProto;
use std::collections::BTreeMap;

/// Generates code for a lazy descriptor map.
///
/// The lazy descriptor map implements the trait
/// grpc_reflection::DescriptorMap for a reflection server.
/// The symbols and binary blobs of the file descriptor proto
/// messages are generated as static code, therefore lazily
/// defined.
///
/// A reflection server implementation must include the
/// file generated by this code and pass it to a
/// grpc_reflection::InfoHandler object.
pub fn from_descriptors(buf: &mut String, files: Vec<FileDescriptorProto>) {
    let lazy = Lazy::new_from_descriptors(&files);
    lazy.into_code(buf);
}

struct Lazy<'s> {
    symbols: SymbolMap<'s>,
    blobs: BTreeMap<&'s str, String>,
    descriptors_idents: BTreeMap<&'s str, syn::Ident>,
}

impl<'s> Lazy<'s> {
    fn new_from_descriptors(files: &'s [FileDescriptorProto]) -> Self {
        let mut symbols = SymbolMap::new();
        files.iter().for_each(|fdp| {
            symbols.insert(fdp.name(), &fdp);
        });

        // Map with the file descriptors encoded as base64
        let blobs: BTreeMap<&str, String> = files
            .iter()
            .map(|fdp| {
                let mut payload: Vec<u8> = Vec::new();
                fdp.encode(&mut payload)
                    .expect("failed to encode as proto message");
                (fdp.name(), base64::encode(&payload))
            })
            .collect();

        // Gather generated names for the descriptors
        // to be used later when referring to the static variables.
        let descriptors_idents: BTreeMap<&str, syn::Ident> = blobs
            .iter()
            .enumerate()
            .map(|(i, (&desc, _))| (desc, quote::format_ident!("DESC_NAME_{}", i)))
            .collect();

        Lazy {
            symbols,
            blobs,
            descriptors_idents,
        }
    }

    fn into_code(self, buf: &mut String) {
        // Write the file descriptor proto names as const strings.
        // The payload are the base64 encoded FileDescriptorProto
        // messages.
        self.declare_static()
            .iter()
            .for_each(|d| buf.push_str(&format!("{}\n", quote::quote! { #d })));

        // Generate the struct declaration first
        let decl_struct = declare_struct();

        buf.push_str(&format!("{}\n\n", quote::quote! { #decl_struct }));

        let impl_struct = self.implement_lazy();

        buf.push_str(&format!("\n{}\n", quote::quote! { #impl_struct }));

        let impl_trait = implement_trait();

        buf.push_str(&format!("\n{}\n", quote::quote! { #impl_trait }));
    }

    // Generates the static variable declarations
    fn declare_static(&self) -> Vec<syn::ItemStatic> {
        let mut punctuated = syn::punctuated::Punctuated::<syn::Lit, syn::Token![,]>::new();

        self.symbols
            .services()
            .map(|s| -> syn::Lit {
                syn::parse_quote! {
                    #s
                }
            })
            .for_each(|l| punctuated.push(l));

        let ret: Vec<syn::ItemStatic> = vec![syn::parse_quote! {
            pub static SERVICES: &[&str] = &[ #punctuated ];
        }];

        self.blobs
            .iter()
            .map(|(&desc_name, _)| (self.descriptors_idents.get(desc_name).unwrap(), desc_name))
            .map(|(ident, path)| syn::parse_quote! { static #ident: &str = #path; })
            .chain(ret.into_iter())
            .collect()
    }

    fn insert_symbols_block(&self) -> Vec<syn::Stmt> {
        self.symbols
            .as_inner()
            .iter()
            .map(|(s, &desc)| {
                let symbol_lit: syn::ExprLit = syn::parse_quote! {
                    #s
                };
                let desc_ident = self.descriptors_idents.get(desc).unwrap();
                syn::parse_quote! {
                    symbols.insert(::std::string::String::from(#symbol_lit), #desc_ident);
                }
            })
            .collect()
    }

    fn insert_blobs_block(&self) -> Vec<syn::Stmt> {
        self.blobs
            .iter()
            .map(|(&desc, blob)| {
                let lit: syn::ExprLit = syn::parse_quote! {
                    #blob
                };
                let desc_ident = self.descriptors_idents.get(&desc).unwrap();
                syn::parse_quote! {
                    blobs.insert(#desc_ident, decode(#lit.as_bytes()).unwrap());
                }
            })
            .collect()
    }

    fn implement_lazy(&self) -> syn::ItemImpl {
        let mut block_insert = syn::Block {
            brace_token: syn::token::Brace::default(),
            stmts: self.insert_symbols_block(),
        };
        block_insert.stmts.extend(self.insert_blobs_block());
        syn::parse_quote! {
            impl LazyDescriptorMap<'static> {
                pub fn new() -> Self {
                    let mut symbols = ::std::collections::HashMap::new();
                    let mut blobs = ::std::collections::HashMap::new();

                    #block_insert

                    LazyDescriptorMap {
                        symbols,
                        blobs
                    }
                }
            }
        }
    }
}

fn declare_struct() -> syn::ItemStruct {
    syn::parse_quote! {
        pub struct LazyDescriptorMap<'s> {
            symbols: ::std::collections::HashMap<String, &'s str>,
            blobs: ::std::collections::HashMap<&'s str, Vec<u8>>,
        }
    }
}

fn implement_trait() -> syn::ItemImpl {
    syn::parse_quote! {
        impl DescriptorMap for LazyDescriptorMap<'static> {
            fn by_symbol(&self, symbol: &str) -> Vec<Vec<u8>> {
                match self.symbols.get(symbol) {
                    Some(desc) => vec![self.blobs.get(desc).expect("descriptor name does not map to a blob").to_vec()],
                    None => vec![vec![]],
                }
            }

            fn by_filename(&self, filename: &str) -> Vec<Vec<u8>> {
                match self.blobs.get(filename) {
                    Some(ref buf) => vec![buf.to_vec()],
                    None => vec![vec![]],
                }
            }
        }
    }
}
