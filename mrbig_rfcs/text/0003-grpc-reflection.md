- Feature Name: `grpc-reflection`
- Start Date: 2020-01-28
- RFC PR: [evooq/mrbig-rfcs#5](https://github.com/evooq/mrbig-rfcs/pull/5)
- MrBig Issue: [evooq/mrbig#18](https://github.com/evooq/mrbig/issues/18)

# Summary
[summary]: #summary

Add a server for gRPC reflection according to [grpc-reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md).

# Motivation
[motivation]: #motivation

> Why are we doing this? What use cases does it support?

Main motivation drivers are:
* Enabling automatic service discovery mechanisms, such as those used by [Gloo](https://www.solo.io/products/gloo/) and [Istio](https://istio.io/), to find `Mr. Big` services.
* Enabling command line tools, such as [grpc_cli](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md), to perform requests to `Mr. Big` services.

> What is the expected outcome?

Uses of `grpc_cli` to *just work*, such as:

```sh
$ grpc_cli ls localhost:50051
helloworld.Greeter
grpc.reflection.v1alpha.ServerReflection
```

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

> Explain the proposal as if it was already included in the language and you were teaching it to another Rust programmer. That generally means:
> - Introducing new named concepts.
> - Explaining the feature largely in terms of examples.
> - Explaining how Rust programmers should *think* about the feature, and how it should impact the way they use Rust. It should explain the impact as concretely as possible.
> - If applicable, provide sample error messages, deprecation warnings, or migration guidance.

To know more about the benefits of using gRPC server reflection, please refer to [grpc-reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md).

gRPC server reflection is enabled by default in `Mr. Big`, assuming your microservice crate has a `build.rs` that compiles your protos with `mrbig_build::compile_protos(...)`:

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    mrbig_build::compile_protos(
        &["proto/helloworld.proto", "proto/other.proto"],
        &["proto/"],
    )?;
    Ok(())
}
```

And that you register at least one endpoint:

```rust
#[derive(Run, Configurable)]
#[mrbig_register_grpc(service = "helloworld.Greeter")]
pub struct Micro {}
```

You can **disable reflection for a single endpoint** when you register using a named argument:
```rust
#[mrbig_register_grpc(service = "helloworld.Greeter", reflection=false)]
```

You can also **disable reflection completely** with:
```rust
#[derive(Run, Configurable)]
#[mrbig_disable_reflection]
pub struct Micro {}
```

Reflection can be tested by using [grpc_cli](https://github.com/grpc/grpc/blob/master/doc/command_line_tool.md).

# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

> This is the technical portion of the RFC. Explain the design in sufficient detail that:
> 
> - Its interaction with other features is clear.
> - It is reasonably clear how the feature would be implemented.
> - Corner cases are dissected by example.
> 
> The section should return to the examples given in the previous section, and explain more fully how the detailed proposal makes those examples work.

Implementing this feature comprises the following tasks:

1. Generating server code for the gRPC reflection server (boilerplate).
2. Gathering proto data for replying to `ServerReflectionRequest`'s.
3. Implementing the responses for the gRPC reflection server.
4. Configuring endpoints to reflect.
5. Deploying the reflection server.
6. Implementing reflection as a cargo feature.

Top level suggested approach is to create a `mrbig_reflection` crate that can be included by the user in the Cargo.toml. `mrbig_reflection` crate shall include reflection server code and struct definitions for handling the data used to reply to the `ServerReflectionRequest` messages.

Ideally, this crate could later be open-sourced or integrated in an open-source community effort (tonic related issue [here](https://github.com/hyperium/tonic/issues/165)).

## Generating server code

Simply put, `mrbig_reflection` crate uses [tonic_build](https://docs.rs/tonic-build/0.1.0/tonic_build/) in the `build.rs` to produce the server code. Then the actual server implementation will include the code generated by `tonic_build`.

*Another option is to simply version control the generated server code, but this is considered poor practice*.

## Gathering proto data for replying to `ServerReflectionRequest`'s
[gathering-proto]: #gathering-proto

To gather the necessary data, we must parse the proto files included by the user when compiling the microservice. Which is similar to what `tonic_build` currently does when generating the gRPC client/server code. Our library's users will not invoke `tonic_build` directly, but rather we'll write a wrapper around `tonic_build::compile_protos()`, similar to:

![single call](/images/codegen-tonic-prost.png)

Unfortunately, the call to `prost_build::compile_protos()` cannot be used once to both generate tonic's server code and do the parsing for the data we must gather. Therefore we'll have to call it twice, as in:

![two calls](/images/codegen-tonic-prost-2.png)

Before the call to `prost_build::compile_protos()` is made, we'll configure `prost_build::Config` with our `prost_build::ServiceGenerator` implementor, which will have access to the parsed syntax of the proto files. That's where we gather the data and fill in the structs defined in `mrbig_reflection`, to be used by the reflection server.

## Implementing the responses for the gRPC reflection server.

Once data has been gathered, the server only has to be initialized properly, use the data gathered upon compilation and encapsulate it in messages of type `google.protobuf.FieldDescriptorProto`, as described in [grpc-reflection](https://github.com/grpc/grpc/blob/master/doc/server-reflection.md):

> This protocol mostly returns FileDescriptorProtos, which are a proto encoding of a parsed .proto file. It supports four queries:
> 
> 1. The FileDescriptorProto for a given file name
> 2. The FileDescriptorProto for the file with a given symbol
> 3. The FileDescriptorProto for the file with a given extension
> 4. The list of known extension tag numbers of a given type

## Configuring endpoints to reflect.

Using a named argument in the `register_endpoint` macro:

```rust
#[derive(Run, Configurable)]
#[register_endpoint(GreeterServer, Greeter, reflection=false)]
struct Micro {}
```

we will know at compile time which proto packages shall be served by the reflection server or not, and adequately filter the data gathered by the proto files compilation.

## Deploying the reflection server.

Deploying the reflection server, or not if configured not to do so, is a matter of adapting the `run()` method generated by our procedural macros.

## Implementing reflection as a cargo feature.

Since all reflection related logic is part of the `mrbig_reflection` crate, it can be included only if the feature reflection is enabled. It should be enabled by default. In `mrbig_derive` we must check if the feature is enabled before calling reflection related methods.

# Drawbacks
[drawbacks]: #drawbacks

The main drawback is a double call to `prost_build::compile_protos` as depicted in [gathering-proto](#gathering-proto), which results in compiling the proto files twice.

# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

# What other designs have been considered and what is the rationale for not choosing them?

To avoid the main drawback we could fork and vendor the `tonic_build` crate, this is up for discussion. It can potentially bring maintenance problems, such as rewriting when `tonic` or `tonic_build` suffer minor/major changes.

# What is the impact of not doing this?

If this feature is not implemented, then service discovery mechanisms will not be able to automatically discover `Mr. Big` services. It would be similar to not having a swagger endpoint when serving a REST API.
