#![warn(rust_2018_idioms)]
#![recursion_limit = "256"]

use futures::{Stream, StreamExt};
use std::pin::Pin;
use std::sync::Arc;
use tonic::{Request, Response, Status, Streaming};

mod proto_includes;
use proto_includes::reflection;

mod info_handler;
use info_handler::InfoHandler;

/// Re-export base64::decode method to be used by
/// generated code.
pub use ::base64::decode;

/// Re-export descriptor map trait.
pub use info_handler::DescriptorMap;

/// Re-export server reflection implementor and trait.
/// These are types generated by tonic_build.
pub use reflection::server_reflection_server::{ServerReflection, ServerReflectionServer};

use reflection::server_reflection_request::MessageRequest;
use reflection::server_reflection_response::MessageResponse;
use reflection::{ServerReflectionRequest, ServerReflectionResponse};

/// `Reflection` provides the necessary scaffolding for
/// running a gRPC reflection server.
///
/// `Reflection` relies on tonic to generate a server
/// from the reflection proto specification. The server
/// is prepared to reply to `ServerReflectionInfo` requests.
///
/// A inner type implementing the [`DescriptorMap`] trait
/// is used to reply to `ServerReflectionInfo` requests.
///
/// **Note**: current implementation does not support
/// protobuf extension related requests.
pub struct Reflection<T: DescriptorMap> {
    info_handler: Arc<InfoHandler<T>>,
}

struct DMap {}
impl DescriptorMap for DMap {}

impl Default for Reflection<DMap> {
    fn default() -> Self {
        Reflection {
            info_handler: Arc::new(InfoHandler::new(vec![], DMap {})),
        }
    }
}

impl<T: DescriptorMap> Reflection<T> {
    /// Create an instance of a [`Reflection`] server.
    ///
    /// Must provide the list of gRPC `service`s that the
    /// are implemented. Must also provide an object that
    /// implements the [`DescriptorMap`] trait.
    pub fn new(services: Vec<String>, dmap: T) -> Self {
        Reflection {
            info_handler: Arc::new(InfoHandler::new(services, dmap)),
        }
    }
}

#[tonic::async_trait]
impl<T: DescriptorMap> ServerReflection for Reflection<T> {
    type ServerReflectionInfoStream = Pin<
        Box<dyn Stream<Item = Result<ServerReflectionResponse, Status>> + Send + Sync + 'static>,
    >;

    async fn server_reflection_info(
        &self,
        request: Request<Streaming<ServerReflectionRequest>>,
    ) -> Result<Response<Self::ServerReflectionInfoStream>, Status> {
        let stream = request.into_inner();
        let info_handler = self.info_handler.clone();

        log::trace!("reflection request: {:?}", stream);

        let output = async_stream::try_stream! {
            futures::pin_mut!(stream);

            while let Some(req) = stream.next().await {
                let req = req?;
                yield handle_reflection_request(&info_handler, req)
            }
        };

        let boxed = Box::pin(output) as Self::ServerReflectionInfoStream;

        Ok(Response::new(boxed))
    }
}

fn handle_reflection_request<T>(
    handler: &Arc<InfoHandler<T>>,
    req: ServerReflectionRequest,
) -> ServerReflectionResponse
where
    T: DescriptorMap,
{
    let message_response: Option<MessageResponse> = match req.message_request {
        None => None,
        Some(ref mreq) => match mreq {
            MessageRequest::ListServices(ref c) => Some(handler.list_services(c)),
            MessageRequest::FileContainingSymbol(ref symbol) => {
                Some(handler.file_containing_symbol(symbol))
            }
            MessageRequest::FileByFilename(ref filename) => {
                Some(handler.file_by_filename(filename))
            }
            MessageRequest::FileContainingExtension(ref ext_req) => Some(
                handler
                    .file_containing_extension(&ext_req.containing_type, ext_req.extension_number),
            ),
            MessageRequest::AllExtensionNumbersOfType(ref ty) => {
                Some(handler.extension_numbers_of_type(ty))
            }
        },
    };

    ServerReflectionResponse {
        valid_host: req.host.clone(),
        original_request: Some(req),
        message_response,
    }
}
